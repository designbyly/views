[
    {
        "id":1,
        "title":"什么是闭包？解释一下",
        "said":"在一个函数中返回另一个函数，里面的函数就成为了闭包, 闭包限制了一定的作用域，保证变量不被释放掉。",
        "showCode":"" 
    },
    {
        "id":2,
        "title":"什么是CSS Hack？解释一下",
        "said":"针对不同的浏览器写不同的CSS code过程，就是CSS Hack",
        "showCode":"" 
    },
    {
        "id":3,
        "title":"Jquery和Zepto的一些区别？",
        "said":"jQuery：将所有功能都放到了一个文件中，用的时候一起用，占用项目的体积。Zepto:更加的轻量，超级适合移动端开发。并不是将所有的功能（Jquery）都封装了，只是封装了一部分。将功能划分为不同的模块，项目中用哪块，就直接取哪块，超级方便。橘子超级推荐",
        "showCode":"" 
    },
    {
        "id":4,
        "title":"说一下事件委派",
        "said":"在一个容器节点上绑定一个事件，利用冒泡规则，判断该事件是否在与之匹配的指定的选择器上执行，容器节点上只能绑定一个事件，一次哦。不需要对每一个目标都进行事件绑定，对于动态插入的节点也可以进行事件绑定，对动态插入的节点生效，无需重新绑定事件",
        "showCode":"" 
    },
    {
        "id":5,
        "title":"Ajax和Jsonp跨域",
        "said":"Ajax：默认无法跨域，xhr2新增的CORS让Ajax可以进行跨域，必须：输出http头，Access-Control-Allow-Origin。Jsonp：可以跨域， script元素的src可以跨域",
        "showCode":"" 
    },
    {
        "id":6,
        "title":"JavaScript严格模式作用和限制有哪些？",
        "said":"作用：消除JavaScript语法的一些不合理的，不严谨，以及怪异问题，消除代码的一些不安全问题保证代码的正常运行，提高编译效率，增加运行速度，为未来的更新迭代做准备。限制：全局变量必须显示声明，禁止this指向全局对象（构造函数，必须加new），函数不能有重复的形参名，保留字",
        "showCode":"" 
    },
    {
        "id":7,
        "title":"iframe问题有啥危害？",
        "said":"阻塞页面的Onload事件，影响页面的整体性能，影响页面的并行加载，和主页共享连接池，但是浏览器对相同域的连接有一定的限制。",
        "showCode":"" 
    },
    {
        "id":8,
        "title":"application cache更新问题",
        "said":"第一次访问manifest文件里面的文件，之后访问先加载缓存，在后台加载manifest文件，按字节对比看是否有变化，如果没有变化则说明缓存没有失败，否则在后台列表里面更新缓存，在下一次刷新页面的时候使用新的资源",
        "showCode":"" 
    },
    {
        "id":9,
        "title":"HTML有哪些新的功能？",
        "said":"本地存储：localStorage，本地存储：sessionStorage，离线缓存：Manifest，新标签：canvas，video，audio，拖放API：drag，drop，地理位置：geolocation，浏览器后台执行：web worker，更多不再叙述",
        "showCode":"" 
    },
    {
        "id":10,
        "title":"简述SASS和Less",
        "said":"CSS预处理工具，编程思路，编写CSS代码快捷，高效，便捷，速度，使用范围：变量，嵌套规则，函数，参数，运算，颜色功能，作用域，更多不再叙述",
        "showCode":"" 
    },
    {
        "id":11,
        "title":"CSS中link和@import区别？",
        "said":"link：link属于标签，页面加载的时候，link同时被加载，link引入样式的权重大于@import，link不存在浏览器兼容问题。@import：@import是CSS引入的，@import引用的时候CSS会在页面加载完成后才会加载引用的CSS，@import是将引用的样式导入到当前的页面中，@import只有在IE5以上才识别。",
        "showCode":"" 
    },
    {
        "id":11,
        "title":"CSS中link和@import区别？",
        "said":"link：link属于标签，页面加载的时候，link同时被加载，link引入样式的权重大于@import，link不存在浏览器兼容问题。@import：@import是CSS引入的，@import引用的时候CSS会在页面加载完成后才会加载引用的CSS，@import是将引用的样式导入到当前的页面中，@import只有在IE5以上才识别。",
        "showCode":"" 
    },
    {
        "id":12,
        "title":"import和require问题",
        "said":"在node中，最重要的思想就是模块化，两者都是被模块化使用。遵循的规范：require是AMD规范引入方式-------------import是ES6语法的一种。import引入要使用必须转换语法，使用babel。require是运行时调用，import是编译时调用，require本质：赋值过程，其结果就是对象，数字，字符串函数等等。import是解构过程，不清楚现在引擎实现了import，三大库可以。",
        "showCode":"" 
    },
    {
        "id":13,
        "title":"SPA",
        "said":"Single Page Application。打开SPA项目的时候，通常只有一个主页面，然后根据点击不同的按钮，切换主页中显示的内容，通过点击不同的按钮（标签），来修改锚点的值。使用路由根据锚点，实现加载不同的页面，不需要进行网页跳转，就可以切换页面，代表类型：微信小程序，Cocos游戏移植",
        "showCode":"" 
    },
    {
        "id":14,
        "title":"加载优化的方法有哪些？",
        "said":"减少HTTP请求，使用懒加载，雪碧图（精灵图），压缩JS，CSS，HTML静态资源并在服务器设置gzip。首屏加载，不要超过120K，压缩图片，避免重定向，上线时候使用第三方库，尽量使用min，按需加载：滚动加载，点击加载等",
        "showCode":"" 
    },
    {
        "id":15,
        "title":"微信JSSDK",
        "said":"项目使用微信的一些功能，比如：扫一扫，定位，支付，分享等。JSSDK使用流程：将自己项目的域名添加到微信公众账号中，并设置为安全域名。在代码中引入JSSDK所需的js文件http://res.wx.qq.com/open/js/jweixin-1.6.0.js，进行配置，调用JSSDK提供的方法进行调用",
        "showCode":"" 
    },
    {
        "id":16,
        "title":"CSS渲染规则",
        "said":"CSS渲染规则：从上到下，从左到右。渲染规则：首先好到所有C，沿着C的父元素查找B，然后顺着B查找A，如果中间找到了符合匹配规则的节点就加入结果集合。如果找到根元素的html都还没有匹配到，这条路径就不再遍历了。下一个A还是如此，直到没有A就继续查找。浏览器的这种查找规则：为了尽早过滤掉一些无关的样式规则和元素",
        "showCode":"" 
    },
    {
        "id":17,
        "title":"浏览器渲染原理",
        "said":"浏览器在接收到服务器返回的html页面之后，浏览器开始构建DOM树（DOM TREE），遇到CSS样式会构建CSS规则树（CSS RULE TREE），遇到JavaScript会通过DOM API和CSS DOM API 来操作DOM TREE和CSS RULE TREE。解析完成后，浏览器引擎会通过DOM TREE和CSS RULE TREE 来构造Rendering TREE（渲染树），渲染树构建完成之后进行布局处理，换一种说法就是确定每个节点在屏幕上的确切的显示位置，最后开始绘制，遍历渲染树，并用UI后端层，绘制出每一个UI节点完成。",
        "showCode":"" 
    },
    {
        "id":18,
        "title":"Ajax兼容问题",
        "said":"正常情况下使用XMLHttpRequest对象就行了，但是在IE浏览器下要使用ActiveXObject对象处理兼容问题。如果使用Jquery，直接使用如下：$.get()，$.post()，$.getJSON()，$.ajax()，以上就可以处理网络请求问题。",
        "showCode":"" 
    },
    {
        "id":19,
        "title":"jQuery扩展插件",
        "said":"jQuery.extend()：给jQuery对象本身扩展方法，jQuery.fn.extend()：给jQuery元素扩展方法。jQuery优势：代码简洁，语法简单，强大的选择器支持，例如：slideUp（），$.each()。很不错的兼容性处理，丰富强大的插件库，完善的AJAX链式语法，完善的文档，免费，开源。",
        "showCode":"" 
    },
    {
        "id":20,
        "title":"作用域链",
        "said":"作用域的范围是函数，函数嵌套函数，查找变量从内层函数依次向外层找，最后找不到在window上找",
        "showCode":"" 
    },
    {
        "id":21,
        "title":"老版本300ms延迟",
        "said":"老版本的webkit的click事件。为了支持双击放大，如果300ms内有两次点击则触发放大操作，而不是click，chromium较新版本在没有双击放大的页面去掉了click事件的300ms延迟。",
        "showCode":"" 
    },
    {
        "id":22,
        "title":"原生触屏事件有哪些？",
        "said":"touchstart,touchmove,touchend,touchcancel",
        "showCode":"" 
    },
    {
        "id":23,
        "title":"清除浮动的方法？",
        "said":"父级元素overflow:hidden，浮动元素的后面的元素clear:both，伪元素选择器：clear:after{content:'';display:block;clear:both}，父级元素设置高度,父级元素display:table",
        "showCode":"" 
    },
    {
        "id":24,
        "title":"常见兼容性问题",
        "said":"各种浏览器默认的margin，padding值不同；iphone7以下会存在划一下滑不动的情况，所以需要写上-webkit-overflow-scrolling：touch；safari时间对象转换，年月日必须要用‘/’new Date（2021/5/22 09:13:24）；IE低版本不识别min-height ，使用！import解决；IE浏览器给图片加载超链接时，图片会自动加上边框（紫色两像素的边框），解决方案： img（border：none/0）；IE9以下的文本输入框不会垂直居中 解决方案：设置line-height属性，window event：表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象 function（e） { e=window.event||e }*，input.type IE 只读 FF可读写。获取页面内所有元素的一个集合 IE：document.all 非IE： document.getElementTagname("*")，DOM2 添加，清除事件（略）。",
        "showCode":"" 
    },
    {
        "id":25,
        "title":"new操作符",
        "said":"创建了一个空的对象，并且this变量引用该对象。同时还继承了该函数的原型，属性和方法被加入到this引用的对象中，新创建的对象由this所引用并且最后隐式的返回this",
        "showCode":"" 
    },
    {
        "id":26,
        "title":"let,const,var三者的区别",
        "said":"var：定义的变量可以修改，如果不初始化会输出undefined，不会报错，会存在变量提升。let：是块级作用域，比如if（）判断中使用let定义之后，对外边没有影响。const：定义的变量币可以修改，而且必须初始化",
        "showCode":"" 
    },
    {
        "id":27,
        "title":"JavaScript常用设计模式",
        "said":"单例模式，原型模式，构造函数，工厂模式，适配器模式，策略模式",
        "showCode":"" 
    },
    {
        "id":28,
        "title":"深拷贝和浅拷贝",
        "said":"浅拷贝：拷贝了对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，拷贝一层，深层次的对象级别的就拷贝引用。深拷贝：另外申请了一块内存，内容和原来对象一样，更改原对象，拷贝对象不会发生变化，拷贝多层，每一级别的数据都会拷贝出来",
        "showCode":"" 
    },
    {
        "id":29,
        "title":"箭头函数",
        "said":"相当于匿名函数，是不能作为构造函数的，不能使用new。不绑定arguments，会捕获其所在的上下文的this值，作为自己的this值。如箭头函数的作用域会继承来自外围的作用域。当方法使用的时候没有定义this的绑定，如需修改this的指向请使用bind，使用call（）和apply（）调用，没有函数原型，不能当做Generator函数，不能使用yield关键字，不能换行。",
        "showCode":"" 
    },
    {
        "id":30,
        "title":"懒加载",
        "said":"别名：延迟加载。叙述：当图片需要显示到页面上的时候，才开始真正的发起图片的网络请求，否则不请求。原理：将图片地址不写入src属性，而是写入其他的属性（data-original）中，页面onload的时候，根据图片的offsetTop值，判断哪些图片显示在用户视野范围内，然后把 这些图片的地址从data-original中取出，放到src属性中，图片会自动请求，设置好onscroll函数，监测屏幕的滚动，如果有图片即将进入用户视野，则同样将图片的地址从data-original取出，放到 src属性中取出即可",
        "showCode":"" 
    },
    {
        "id":31,
        "title":"预加载",
        "said":"在页面正式显示之前，先把所需要的图片资源全部加载下来，然后再显示界面 ，用户就不会看到图片加载的过程了，提高了用户体验。加载原理：拿到所有图片的地址，分别创建Image对象，并赋值给src，在imgObj.onload方法中，判断是否所有图片都已经加载完毕，当所有图片加载完毕之后，调用回调函数，处理页面的显示",
        "showCode":"" 
    },
    {
        "id":32,
        "title":"call,apply,bind的区别",
        "said":"call：调用一个函数，并指向this和参数，第一个参数是指定的this的值 第二个参数开始的参数是替换的参数。apply：调用一个函数，并指向this和参数，第一个参数是指定的this的值 第二个参数是一个数组，bind：由一个函数创建一个新函数，并绑定this和部分参数，参数形式和call类似",
        "showCode":"" 
    },
    {
        "id":33,
        "title":"水平垂直居中的方法",
        "said":"已知宽高，设置position:absolute，然后left，和top都设置为50%，再根据margin的数值来调整，类似第一个，最后一步用transfrom ：translate（-50%，-50%）；绝对定位，top，bottom，left，right都设置为0，设置好宽度，然后margin：auto；display：table-cell；vertical-align：middle；使用flex弹性盒布局",
        "showCode":"" 
    },
    {
        "id":34,
        "title":"display:inline-block显示的空隙解决方法",
        "said":"float，margin负值，float-size：0，letter-spacing，word-spacing",
        "showCode":"" 
    },
    {
        "id":35,
        "title":"简述flex布局",
        "said":"别名：弹性布局。使用flex布局，会更加方便与迅捷，但是有一定的兼容问题，display：-webkit-flex。主要含有主轴，交叉轴的概念，通过弹性布局，可以很方便的设置元素的左对齐，右对齐，上对齐，下对齐，居中对齐等各种对齐方式，快速实现页面效果。常用属性：flex-direction，flex-wrap，justify-content，align-items，align-content，flex-grow，flex-shrink，flex-basis，align-self",
        "showCode":"" 
    },
    {
        "id":36,
        "title":"CSS3新属性",
        "said":"更多的选择器；弹性布局：flex；帧动画：keyframes/animations；多列布局：column；背景渐变：linear-gradient/radial-gradient；背景属性：background-image/background-size/background-clip/background-origin；边框，阴影：border-image/border-radius/box-shadow；2D,3D变化：transform/transform-origin；用户界面属性添加：box-sizing/outline-offset/cursor；更多的属性值",
        "showCode":"" 
    },
    {
        "id":37,
        "title":"HTTP状态码",
        "said":"100-199：用于指定客户端应响应的某些动作。200-299：表示请求成功。300-399：已经移动的文件并且常被包含在定位头信息中指定的新的地址信息。400-499：用于指定客户端的错误。400：当前请求无法被服务器理解；401：当前请求需要用户验证；403：服务器已经解决请求，但是拒绝执行它。500-599：用于支持服务器错误；503，服务不可用",
        "showCode":"" 
    },
    {
        "id":38,
        "title":"node优缺点？",
        "said":"优点：node基于事件驱动和无阻塞的，非常适合处理并发请求。构建在node的代理服务器相对于其他技术如Ruby等表现要好的多，橘子推荐。与node代理服务器交互的客户端代码是由JavaScript语言编写的，因此客户端和服务端都用同一种语言编写，非常漂亮。缺点：是一个开源项目，不太稳定，一直在变化，缺少足够的第三方库的支持，如同当年的Ruby或者Rails",
        "showCode":"" 
    },
    {
        "id":39,
        "title":"href和src区别",
        "said":"href：Hypertext Reference。执行网络的资源所在的位置，建立和当前元素（锚点），或者是当前文档之间的链接。src：替换当前元素，source 指向外部资源的位置，指向的内容会嵌入到文档中当前的标签所在的位置，在请求src资源的时候会将其指向资源下载并应用到文档中，例如：js脚本，img图片，frame等元素。",
        "showCode":"" 
    },
    {
        "id":40,
        "title":"防止恶意调用API的方法",
        "said":"验证码，频率，限制设备发送数据次数，归属地匹配，可疑用户，黑名单，签名，启动签名策略，token值，代码混谣，启用https，风控，肉鸡来袭进行判断锁定，及时止损，数据安全，过滤恶意API",
        "showCode":"" 
    },
    {
        "id":41,
        "title":"block,inline,inline-block区别",
        "said":"inline：inline元素和其他inline元素在同一行展示，不能设置宽高margin，padding不能设置纵向，可以设置横向；block：block元素在新行开始，默认宽度为容器的宽度，可以设置宽度；inline-block：从外面看是inline，里面看是block，可以设置宽度",
        "showCode":"" 
    },
    {
        "id":43,
        "title":"谈一谈对this的理解",
        "said":"是JavaScript的一个关键字，随着函数使用场合的不同this的值不断变化。有一个总的原则：this指的是调用函数的那个对象，一般情况下，是全局对象Global，作为方法调用，this指的就是这个对象",
        "showCode":"" 
    },
    {
        "id":44,
        "title":"虚拟DOM",
        "said":"虚拟DOM就是为了解决浏览器性能问题而被设计出来的。举例说明：若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个JS对象中，最终将这个JS对象一次性attch，到DOM树上，再进行后续操作，避免大量计算量。好处：用JS对象模拟DOM节点，页面的更新可以先全部反应在JS对象中的JS对象映射成真正的DOM，交给浏览器去绘制,",
        "showCode":"" 
    },
    {
        "id":45,
        "title":"CSS优化",
        "said":"把Stylesheets放到HTML页面头部；层次不要超过三层；合并CSS规则，合并margin，background等属性；不要在id选择器和class选择器前使用标签名；移除空的CSS规则；去掉0的单位；多使用继承属性，不要声明过多的font-size；少用position:absolute；平铺的图片不要太小，1px的图片平铺长度25px的区域块需要2500次后果影响渲染速度；使用简写样式；尽量少用通配符，只用通配符设置一切基础的样式",
        "showCode":"" 
    },
    {
        "id":46,
        "title":"渲染优化",
        "said":"动画优化：使用CSS3动画，使用requestAnimationFrame替代setTimeout；高频事件优化：touch事件，scroll事件；图片优化：二次压缩图片，webp》jpg》png8》gif，对图片使用lazyload，避免使用DataURL；GPU加速：使用transition触发，tranfrom触发，opacity；DOM层次不应该太多；JS主动释放内存",
        "showCode":"" 
    },
    {
        "id":47,
        "title":"脚本执行优化",
        "said":"避免iframe，img等src为空；图片尽量避免使用DataURL；避免重设图片大小；点击事件优化；注意scroll resize事件绑定时机。",
        "showCode":"" 
    },
    {
        "id":48,
        "title":"做的页面在哪些浏览器测试过，这些浏览器内核是什么",
        "said":"IE:trident内核；Firefox：gecko内核；Safari：webkit内核；Opera：以前是presto内核，Opera现在已经是Google Chrome的Blink内核；Chrome：Blink（基于webkit，Google与Opera Software共同开发）。",
        "showCode":"" 
    },
    {
        "id":49,
        "title":"每个HTML文件中开头的Doctype，你知道是干什么的吗",
        "said":"!DOCTYPE 声明位于文档最前面的位置，处于html标签之前。此标签可以告知浏览器文档使用哪种HTML或者XHTML规范。重点：告诉浏览器按照何种规范解析页面。",
        "showCode":"" 
    },
    {
        "id":50,
        "title":"Quirks模式是什么？，它和Standards模式的区别，",
        "said":"从IE6开始，就引入了Standards模式，标准模式中，浏览器尝试在给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度，IE6之前CSS的不成熟，因此IE5等浏览器对CSS的支持就很差劲。IE6能提供更好的支持，问题出现，很多页面都是以旧的布局方式写的，如果IE6支持CSS会将这些页面显示不正常。IE6出来挨打系列。问题：如何在保证不破坏现有页面，又提供新的渲染机制？我们在写程序的时候，也会遇到各种浏览器调试问题，如何保证接口不变的情况下，又提供强大的功能了？常见做法：增加参数和分支，就是当某个参数为真的时候，就使用新的功能，如果这个参数不为真的时候呢，橘子姐姐推荐使用旧功能。这样就不会破坏原来的程序，而且可以提供新的功能。IE6也是这样做的，它将DTD当做这个“参数”，因为以前的页面大家都不会写DTD，所以IE6假定，如果写了DTD，就意味着这个页面采用了对CSS支持的更好的布局，如果没有，就采用兼容之前的布局。这就是Quirks模式。Quirks模式别名：怪癖模式，诡异模式，怪异模式。区别：总体会有布局，样式，脚本执行三个方面的区别。盒模型：在W3C标准中，如果设置了一个元素的宽度和高度，这里指的是元素内容的宽度和高度，而在Quirks模式下，IE的宽度和高度还包含了padding和border。超级多，不一一举例了。答出什么不重要，关键是答出的是否自己遇到过，还是读CSDN，看文章看的，甚至完全不知道。跟着姐姐走，你会体会到前端和C语言的强大之处，加油。",
        "showCode":"" 
    },
    {
        "id":51,
        "title":"div+css布局与table布局相比，有什么优点？",
        "said":"改版的时候更加的方便，只要改CSS样式就行了。页面加载速度非常的快，结构化非常的清晰，页面显示非常的简洁，表现与解构分离，易于SEO优化，搜索引擎更加的友好，网站排名更容易靠前，橘子姐姐祝愿大家找到一个好工作",
        "showCode":"" 
    },
    {
        "id":52,
        "title":"img中的alt和title有何异同？strong与em的异同？",
        "said":"a:alt(alt text):不能显示图像，窗体或者applets用户代理（UA），alt属性用来指定替换的文字。替换的文字的语言由lang属性指定。在IE浏览器下会在没有title时把alt当成tool tip显示。title(tool tip):该属性为设置该属性的元素提供的建议性的一些信息。粗体强调标签，强调，说的就是内容的重要性，橘子姐姐说的，斜体强调标签，更强烈强调，表示内容的强调点。",
        "showCode":"" 
    },
    {
        "id":53,
        "title":"img中的alt和title有何异同？strong与em的异同？",
        "said":"a:alt(alt text):不能显示图像，窗体或者applets用户代理（UA），alt属性用来指定替换的文字。替换的文字的语言由lang属性指定。在IE浏览器下会在没有title时把alt当成tool tip显示。title(tool tip):该属性为设置该属性的元素提供的建议性的一些信息。粗体强调标签，强调，说的就是内容的重要性，橘子姐姐说的，斜体强调标签，更强烈强调，表示内容的强调点。",
        "showCode":"" 
    },
    {
        "id":54,
        "title":"描述一下渐进增强和优雅降级之间的不同",
        "said":"渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果，交互等改进和追加功能达到更好的用户体验。观点，认为关注的内容本身，内容是构建网站的原因，有的网站展示它，有的收集信息，有的操作，有的寻求，还有的网站甚至包含以上的种种。但相同点是他们全都涉及到内容，橘子姐姐这么一说，是不是感觉这是一种很合理的设计理念？这立即被Yahoo，采纳并被用来构建其“分级式浏览器支持（Graded Browser Support）”策略的原因。优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容处理观点。认为应该针对的是那些最高级，最完善的浏览器来设计网站。那些被认为过时的，或者功能缺失的网站，其测试工作安排在开发周期的最后阶段，把测试对象限定为主流浏览器的前一个版本。这种设计规范，旧版的浏览器被认为无能的用户体验。你可以做一些小调整来适应某个特定的浏览器，他们并非我们所关注的焦点，因此处理修复重大bug，其他的差异直接忽略不计。两者之间的区别：优雅降级是从复杂的现状开始的，并试图减少用户体验的供给，而渐进增强是从一个非常基础的，能够起作用的版本开始的，并不断的扩充，以适应未来版本的需要。降级（功能衰减）意味着往回看，而渐进增强意味着朝前看，同时保证其根基出于安全地带。",
        "showCode":"" 
    },
    {
        "id":55,
        "title":"为什么利用多个域名来存储网站资源会更有效？",
        "said":"CDN缓存更方便，突破浏览器并发限制，节约Cookie宽带，节约主域名的连接数，优化页面响应速度，防止不必要的安全问题。",
        "showCode":"" 
    },
    {
        "id":56,
        "title":"请描述一下cookie，sessionStorage和localStorage的区别？",
        "said":"sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也会销毁。因此sessionStroage不是一种持久化的本地存储，仅仅适用于会话级别的存储。localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。cookie问题：web storage 和 cookie 的区别，web storage的概念和cookie相似，区别是为了更大容量存储设计的。cookie的大小有一定的限制，并且每次一个新的页面cookie都会被发送过去。 这样，无形之中就浪费了带宽。cookie1还需要指定作用域，不可以跨域调用。setitem，getitem，removeitem，clear等方法，不像cookie需要你自己封装setCookie，getCookie，cookie也是不可以或缺的，cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，web Storage 只是为了在本地“存储”数据而产生的。",
        "showCode":"" 
    },
    {
        "id":57,
        "title":"JS脚本放在底部的原因？",
        "said":"当浏览器解析到该元素的时候，会暂停其他资源的下载和处理。直到将该资源加载，编译，执行完毕。图片，框架等元素也是如此，类似于将所指向资源嵌入当前标签内",
        "showCode":"" 
    },
    {
        "id":58,
        "title":"Webp技术拓展",
        "said":"谷歌开发的一种加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，可以节省大量的服务带宽资源和数据空间，Face，Ebay等开始测试使用了。",
        "showCode":"" 
    },
    {
        "id":59,
        "title":"谈一谈你对网页标准和标准制定机构重要性的理解？",
        "said":"网页标准和标准制定机构都是为了能让web开发和发展的更加的“健康”，开发者遵循统一的标准，降低开发难度，开发成本。SEO也会更好做，也不会因为滥用代码导致的各种BUG，最终可以提高网站的易用性。",
        "showCode":"" 
    },
    {
        "id":60,
        "title":"前端微格式是什么？，谈一谈你的看法",
        "said":"微格式：（Microformats）：是一种可以让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊的应用而制定的特殊格式。微格式优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。",
        "showCode":"" 
    },
    {
        "id":61,
        "title":"代码发布上线之后要进行性能优化，从用户刷新网页开始，一次JS请求一般情况下有哪些地方会有缓存处理？",
        "said":"DNS缓存；CDN缓存；浏览器缓存；服务器缓存",
        "showCode":"" 
    },
    {
        "id":62,
        "title":"电商网站大量的图片，你是如何优化这些图片加载的？",
        "said":"图片懒加载：在页面的未可视区可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载，如果为幻灯片，相册：可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。如果为CSS图片：可以使用CSSsprite，SVGsprite，Iconfont，Base64技术，如果图片大的不成样子，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。如果图片展示区域小于图片的真实大小，则应该在服务器根据业务进行图片压缩，图片压缩后大小与展示一致。",
        "showCode":"" 
    },
    {
        "id":63,
        "title":"使得一个DOM元素不显示在浏览器可视范围内的方法",
        "said":"方法1：设置display属性为none，或者设置visibility属性为hidden；方法2：设置宽高为0，设置透明度为0，设置z-index位置在1-1000",
        "showCode":"" 
    },
    {
        "id":64,
        "title":"超链接访问过后hover样式就不出现，怎么解决这个问题?",
        "said":"被点击访问过的超链接样式不再具有hover，active了，解决办法：改变CSS属性的排列顺序，L-V-H-A：link,visited,hover,active",
        "showCode":"" 
    },
    {
        "id":65,
        "title":"行内元素和块级元素的具体区别是什么？，行内元素的padding和margin可以设置吗？",
        "said":"块级元素（block）特性：总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示。宽度，高度，内边距，外边距都可以控制。内联元素（inline）特性：和相邻的内联元素在一行。宽度，高度，内边距的top,bottom,padding-top,padding-bottom都不可以改变，padding和margin的Left和right是可以设置的，说的就是里面的文字或者图片的大小。橘子姐姐提问：浏览器默认的inline-block元素有哪些？答：input,img,button,textrea,label",
        "showCode":"" 
    },
    {
        "id":66,
        "title":"外边距重叠会发生什么后果？什么是外边距重叠？",
        "said":"外边距重叠（margin-collapse）：在CSS中，相邻的两个盒子的外边距可以结合成一个单独的外边距，这种合并外边距的方式称作折叠，并且因为其所结合合成的外边距称为折叠外边距。折叠规则的计算规则：两个相邻的外边距都是正数的时候，折叠结果是他们中较大的那个值，两个相邻的外边距都是负数的时候，折叠结果是他们绝对值中较大的那个值。两个外边距一正一负的时候，折叠结果是两者相加的和",
        "showCode":"" 
    },
    {
        "id":67,
        "title":"外边距重叠会发生什么后果？什么是外边距重叠？",
        "said":"外边距重叠（margin-collapse）：在CSS中，相邻的两个盒子的外边距可以结合成一个单独的外边距，这种合并外边距的方式称作折叠，并且因为其所结合合成的外边距称为折叠外边距。折叠规则的计算规则：两个相邻的外边距都是正数的时候，折叠结果是他们中较大的那个值，两个相邻的外边距都是负数的时候，折叠结果是他们绝对值中较大的那个值。两个外边距一正一负的时候，折叠结果是两者相加的和",
        "showCode":"" 
    },
    {
        "id":68,
        "title":"rgba（）和opacity的透明效果有啥区别？",
        "said":"rgba()和opacity都可以实现透明效果。区别：opacity作用于元素，以及元素内的所有内容的透明度，rgba（）只作用于元素的颜色或者背景色。橘子姐姐温馨提示：设置rgba透明的元素的子元素不会继承透明元素哦。",
        "showCode":"" 
    },
    {
        "id":69,
        "title":"说一说px和em的区别",
        "said":"都是长度单位，区别：px的值固定，指定多少就是多少。em的值不固定，并且em会继承父级元素的字体大小。浏览器默认字体大小16px；1em=16px；12px=o.75em；10px=0.625em",
        "showCode":"" 
    },
    {
        "id":70,
        "title":"描述一个“reset”的CSS文件并如何使用它，知道normalize.css吗？你了解他们的不同之处吗？",
        "said":"重置样式非常的多，你肯定有一个常用的重置CSS的文件并如何使用它。不同的浏览器有对一些元素有不同的默认样式，如果不处理，在不同的浏览器下必定存在必要的风险甚至会有戏剧性的一幕。Normalize来替代你的重置样式文件。但是，他没有重置所有的样式风格，但是又提供了一套合理的默认样式，这样既可以使得很多浏览器达到一致的合理性，但是又不扰乱其他的东西，在这一方面，无法做每一个位置都复位重置。它确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或者line-height不一致。",
        "showCode":"" 
    }
]
